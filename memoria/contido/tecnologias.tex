\chapter{Tecnologías utilizadas}
\label{chap:tecnologias}

\lettrine{E}{n} este capítulo se presentan las herramientas tecnológicas utilizadas durante el desarrollo de este trabajo, al igual que la justificación de su elección sobre otras alternativas.

En primer lugar, se presentan las herramientas tecnológicas empleadas para el desarrollo y entrenamiento de los modelos de perfilado automático seleccionados. Por otro lado, tenemos las dedicadas a la construcción de la aplicación web. Por último, se exponen las herramientas de ayuda al desarrollo que se han utilizado de manera integral durante todo el proceso software.

\section{Algoritmos de perfilado}

En esta sección se muestran las herramientas empleadas para la creación y entrenamiento de los modelos de perfilado automático, así como para la extracción, carga y preprocesado de los conjuntos de datos de entrenamiento y test.

\subsection{Python}
\label{subsec:python}

Python\footnote{\url{https://www.python.org/}} es un lenguaje de programación de alto nivel, interpretado y multiparadigma. Actualmente es uno de los lenguajes de programación más populares en diversos ámbitos como la ciencia y análisis de datos, inteligencia artificial y programación web. Algunas de las razones por las que es tan popular son: su sintaxis sencilla y legible, su baja curva de aprendizaje, pero sobre todo el gran soporte que tiene en cuanto a librerías populares como PyTorch, Pandas, Numpy, Tensorflow o Scikit-learn, ampliamente utilizadas en el ámbito de la ciencia de datos y el aprendizaje automático.

\subsection{Scikit-learn}

Scikit-learn\footnote{\url{https://scikit-learn.org/stable/}} es la librería por excelencia en python para el desarrollo de modelos de aprendizaje automático diferentes de redes neuronales. Esta cuenta con una gran variedad de modelos para tareas de clasificación, regresión o agrupamiento como \gls{svm}, \gls{lr}, árboles de decisión... Además, también dispone de módulos para el procesado de las características textuales, funciones de evaluación de los clasificadores y realización de validación cruzada.

Como alternativa a esta tenemos a MLlib\footnote{\url{https://spark.apache.org/mllib/}} de Spark que permite realizar trabajos de aprendizaje automático de manera distribuida. Sin embargo, su uso sería un poco innecesario pues los modelos creados con Scikit-learn se pueden ejecutar en el equipo local sin problemas ya que no suponen una gran carga computacional.
Se usaron las implementaciones de esta librería para los modelos como \gls{svm} y \gls{lr}, además de las funcionalidades de preprocesado, validación cruzada y  evaluación mencionadas antes.

\subsection{Tensorflow, Keras y Transformers}

Tensorflow\footnote{\url{https://www.tensorflow.org/}} es una librería de código abierto creada por Google para el desarrollo de modelos basados en redes neuronales. Tiene una gran capacidad de distribución y optimización, permitiendo la aceleración por hardware de sus modelos mediante el uso de varios núcleos de CPUs, GPUs y TPUs. Una gran ventaja de Tensorflow respecto a PyTorch (las dos librerías de aprendizaje profundo más populares) es su gran integración con Keras\footnote{\url{https://keras.io/}}.

Keras es un API de alto nivel construído por encima de Tensorflow que simplifica muchas de las operaciones habituales de Tensorflow. De esta forma, su facilidad de uso hace que sea ideal para principiantes en el aprendizaje profundo, pues es más fácil de aprender que las otras dos APIs de más bajo nivel.

Por otro lado, Transformers\footnote{\url{https://huggingface.co/docs/transformers}} es otra biblioteca de código abierto desarrollada por Hugging Face, muy usada en el ámbito del \acrshort{nlp} y en visión artificial. Esta librería pone a disposición del público una gran variedad de modelos preentrenados de aprendizaje profundo. Estos están disponibles en distintos idiomas, como los utilizados de BERT y RoBERTa, y además admiten la posibilidad de usar aceleración por hardware. En cuanto a modelos de lenguaje avanzados no existe realmente ninguna alternativa a esta.

\subsection{Jupyter Notebooks y Google Colab}

Las Jupyter Notebooks se tratan de documentos interactivos formados por celdas que pueden incluir código, texto de marcado y gráficas. El hecho de poder ejecutar una celda y que se muestre la salida de la misma justo debajo en formato numérico, de texto o en una gráfica, hace que sean ideales para el ámbito del análisis y ciencia de datos, además de inteligencia artificial y propósitos educativos.

Por otro lado, Google Colaboratory\footnote{\url{https://colab.google/}} es una plataforma de Google que dispone de recursos gratuitos de ejecución en la nube de documentos Jupyter Notebooks. Permite la ejecución de código Python, y cuenta con multitud de librerías populares ya preinstaladas como Tensorflow. También proporciona acceso gratuito a recursos de aceleración por hardware como GPUs y TPUs.

Se hizo uso de Colab debido a la gran carga computacional que supone el entrenamiento modelos de aprendizaje profundo, basados en grandes modelos del lenguaje como son BERT y RoBERTa, lo que hace que sea imposible entrenarlos en un equipo convencional sin hardware especializado como GPUs y TPUs. Aunque Kaggle es otra plataforma similar que proporciona acceso a hardware dedicado gratuitamente, se optó por Colab debido a su entorno ya integrado de librerías preinstaladas.

\subsection{Kaggle y Playwright}

Kaggle es una plataforma online que tiene una gran comunidad dedicada a la ciencia de datos. Esta además de albergar competiciones, conjuntos de datos y recursos para la enseñanza de aprendizaje automático, dispone de kernels de uso gratuito de ejecución en la nube de código en forma de Jupyter Notebooks en lenguaje Python y R. Estos kernels ponen a disposición del público recursos de computación como GPUs y TPUs para la aceleración por hardware del entrenamiento de modelos de aprendizaje automático. Además se puede programar la ejecución de cargas de trabajo (para la extracción de datos por ejemplo) de forma asíncrona con duración de hasta 12 horas.

Por otro lado, Playwright\footnote{\url{https://playwright.dev}} es una biblioteca de Python para la realización de \gls{end2end} sobre aplicaciones web. Al igual que otras bibliotecas de pruebas como Selenium\footnote{\url{https://www.selenium.dev/}} o Pupeteer\footnote{\url{https://pptr.dev/}}, se pueden utilizar para hacer \gls{web_scraping}. La elección de Playwright sobre las anteriores es debido la posibilidad de ejecutar el navegador en modo headless, es decir, sin interfaz de usuario. Este hecho lo hace ideal para la ejecución de scrapers en plataformas en la nube como Kaggle.

De esta manera, se usaron conjuntamente estas dos herramientas para la extracción de los textos de los tweets que forman parte del conjunto de datos de 2016 \ref{sec:datasets}.

\section{Aplicación web y servicios}

En esta sección, se explican las herramientas empleadas para la creación de la aplicación web. Estas incluyen las referentes al micro-servicio de perfilado, a la capa servidor que constituye el \textit{backend} de la aplicación y se comunica con la base de datos y a la capa cliente o \textit{frontend} de la aplicación.

En este punto, cabe mencionar que se creó el módulo de perfilado automático como un micro-servicio al margen del resto de la capa servidor de la aplicación. La razón fue que los modelos usados para el perfilado estaban escritos en una versión de Python ya en desuso como es Python 2.7. De este modo, se decidió conservar estos modelos en esta versión debido a los problemas que supondría hacer la migración a una versión más reciente. No obstante, se juzgó adecuado desarrollar el resto de la capa servidor, que se comunica con la base de datos y el ya mencionado micro-servicio de perfilado, en una versión más reciente (como es Python 3.10) por motivos evidentes de seguridad y compatibilidad.

\subsection{\textit{Backend}}

\subsubsection{Flask}

Para la creación tanto de la capa servidor como del micro-servicio de perfilado se optó por Flask\footnote{\url{https://flask.palletsprojects.com/en/2.3.x/}}. Flask es un micro-framework para el desarrollo de aplicaciones web. Se le denomina micro-framework debido a su simplicidad y sencillez de uso. Simplifica enormemente la definición rutas para el procesado de peticiones HTTP, mediante el uso del decorador \textit{route} delante de la función que procesará dicha petición.
También se barajó el uso de una alternativa popular como Django\footnote{\url{https://www.djangoproject.com/}}, el cual es un framework mucho más completo que dispone de forma de predeterminada de funcionalidad para facilitar la autenticación, y la administración de bases de datos, lo que lo hace ideal para proyectos grandes. No obstante, al ser más completo Django también tiene una curva de aprendizaje más alta por lo que en nuestro caso se decidió usar Flask ya que se consideró que la web a construir sería relativamente sencilla (sin necesidad de autenticación, o demasiada administración) y se prefirió la flexibilidad que nos aporta un framework pequeño como este.

Cabe mencionar que como opción para la validación de datos y serialización de los recursos del API se optó por \textbf{Pydantic}\footnote{\url{https://docs.pydantic.dev/latest/}}. Esta es una moderna librería de python que permite la validación de los datos de entrada, de una forma declarativa, proporcionando un tipado estático de los mismos mediante el uso de las recientemente introducidas anotaciones de tipo de python (PEP 484). Esta característica es especialmente relevante en un lenguaje de tipado dinámico como es python facilitando así la detección de errores en tiempo de compilación.

\subsubsection{Gunicorn}

Como servidor web WSGI se ha optado por Gunicorn\footnote{\url{https://gunicorn.org/}}. La especificación \acrfull{wsgi} se utiliza en el marco de las aplicaciones web desarrolladas en python para referirse a un módulo intermedio entre la aplicación web y el servidor de peticiones HTTP que define la comunicación entre los mismos. Estos servidores permiten la separación de responsabilidades entre la aplicación web que contiene la lógica de la misma y el servidor que se encarga de aspectos como la gestión de conexiones.

Los principales motivos de utilización de gunicorn son: su facilidad de uso, la disponibilidad de un entorno de ejecución concurrente con independencia entre hilos, la compatibilidad con diferentes frameworks basados en WSGI como Flask o Django; y por último la facilidad de integración con herramientas de administración de contenedores como es en este caso Docker.

\subsection{\textit{Frontend}}
\subsubsection{HTML5, CSS y JavaScript}

\acrfull{html}\footnote{\url{https://developer.mozilla.org/es/docs/Web/HTML}} es un lenguaje de marcado que se ha convertido en el estándar para la construcción de páginas web. Está definido por el \acrfull{w3c} que se encarga de la estandarización de las tecnologías asociadas a la web. Este lenguaje define la estructura y significado del contenido de las páginas web. La versión actual que entienden la mayoría de navegadores modernos es la 5.

\acrfull{css}\footnote{\url{https://developer.mozilla.org/es/docs/Web/CSS}} por otro lado, es un lenguaje de diseño gráfico, estandarizado también por el \acrshort{w3c}, define el estilo de las páginas web en cuanto a su presentación visual. Su objetivos es marcar la separación entre el contenido de una página web y su presentación (colores, fuentes, \textit{layouts}...).
Cabe mencionar que el diseño de la web se ha realizado partiendo de una hoja de estilos basada en elementos como es \textbf{Water.css}\footnote{\url{https://watercss.kognise.dev/}}.

Por último, JavaScript\footnote{\url{https://developer.mozilla.org/es/docs/Web/JavaScript}} es un lenguaje de programación de alto nivel, multiparagidma e interpretado que es utilizado principalmente en el desarrollo web para agregar interactividad y dinamismo a las páginas web a través de la manipulación del \acrfull{dom}. Es un lenguaje multi-plataforma ya que se ejecuta en la mayoría de navegadores web modernos, aunque también es utilizado en entornos fuera del navegador. Hoy en día, se ha popularizado su uso mediante diferentes librerías o \textit{frameworks} que facilitan el desarrollo web como pueden ser ReactJs, AngularJs o VueJs.

\subsubsection{ReactJs, JSX y React Router}

\textbf{ReactJs}\footnote{\url{https://react.dev/}} es una librería JavaScript de código abierto diseñada para facilitar el desarrollo de interfaces web \acrfull{spa}. Fue desarrollada por Facebook con la idea de facilitar la creación de interfaces <<reactivas>>.

Está basada en la reutilización del código a través de la creación de componentes. Estos son bloques de código que representan una parte de la interfaz de usuario y se pueden usar para crear páginas web más complejas. Cada componente se encarga por tanto de renderizar una parte de la interfaz HTML.

Por este motivo, se utiliza la extensión de lenguaje \textbf{JSX} (JavaScript XML) que tiene una sintaxis muy similar al código HTML, con la diferencia de que admite la incorporación de otros componentes React dentro del mismo lenguaje, favoreciendo de esta manera la creación y mantenimiento de nuevos componentes.

Otro punto importante de React es el uso de un Virtual \acrshort{dom}, y es que React mantiene un árbol \acrshort{dom} virtual que se actualiza cada vez que cambia el estado de una parte de la interfaz, para luego aplicar los cambios, únicamente en aquellas partes del \acrshort{dom} del navegador que han sido afectadas por el mismo, favoreciendo así el rendimiento de la web.

Por otro lado, React no se considera un \textit{framework} JavaScript como tal. Esto es, entre otros motivos debido a que no incorpora elementos como el mantenimiento del estado o el enrutamiento, de forma nativa. Por este razón, se ha escogido usar \textbf{React Router} que sirve para la gestión de la navegación de las páginas web (\acrshort{spa}) desarrolladas con React. Esta extensión, permite implementar la navegación de diferentes vistas sin necesidad de recargar la interfaz completa, de manera aparentemente idéntica a como se navegaría entre distintas páginas en una web tradicional, pero sin la sobrecarga adicional de recargar toda la página. Asimismo, permite definir las diferentes rutas de la página web de forma declarativa, especificando que componente React se debe renderizar según la ruta que se cargue de la misma, facilitando la organización y comprensión del proyecto.

\subsubsection{ChartJs}

ChartJs\footnote{\url{https://www.chartjs.org/}} es un librería de JavaScript que facilita la creación de gráficos HTML. Pone a disposición del usuario una forma sencilla de crear gráficos y visualizaciones web interactivos y visualmente atractivos. Además de su facilidad de uso destaca la gran capacidad de personalización de sus visualizaciones.
Otra librería que se tuvo en cuenta para crear los gráficos de la web fue D3.js que se basa en la selección y manipulación directa de elementos HTML y SVG, tiene una gran flexibilidad y permite crear unos diseños mucho más personalizables que ChartJs. Sin embargo, su enfoque altamente imperativo contrasta bastante con la filosofía principalmente declarativa de React, además de esto su mayor complejidad de uso supone una barrera trabajando con plazos ajustados.
\subsection{Persistencia}
Con el objetivo de mantener un registro de las colecciones y usuarios perfilados en nuestra web, se juzgó necesario disponer de cierto tipo persistencia. Sin embargo, la hora de elegir el tipo de persistencia a utilizar, el hecho de que nuestro modelo de datos no tenga una estructura predefinada clara, la naturaleza no estructurada del texto proveniente de comentarios de redes sociales y la preferencia por una mayor flexibilidad de los datos que por su integridad, dio lugar que se optase por un sistema de gestión de bases de datos no relacional. 
\subsubsection{MongoDb}
MongoDb\footnote{\url{https://www.mongodb.com/}} es un sistema de gestión de bases de datos \acrfull{nosql} de código abierto y orientado a documentos. Esto es en vez de guardar la información en tablas y filas como las bases de relacionales, lo hace en documentos BSON (Binary Json). Es ampliamente utilizado en el contexto del desarrollo web debido a su gran flexibilidad, escalabilidad y eficiencia para manejar grandes volúmenes de datos.
%MAYBE TODO poner alternativas a mongodb
\section{Herramientas de desarrollo}
\subsection{Docker}
Docker\footnote{\url{https://www.docker.com/}} es una plataforma que permite el desarrollo, envío y despliegue de aplicaciones de forma aislada en unidades llamadas contenedores. Los contenedores son unidades mínimas que incluyen todo el código, librerías y dependencias necesarias para ejecutar una aplicación.

Al igual que las máquinas virtuales son una forma de virtualización de un equipo informático incluyendo su hardware, los contenedores se pueden ver como una forma de virtualización del sistema operativo. Esto permite que pueda haber múltiples aplicaciones distintas corriendo en una misma máquina, cada una de forma aislada con su propio entorno, mediante el uso de contenedores.

Los beneficios del uso de contenedores por tanto, son la portabilidad, aislamiento, seguridad, eficiencia de recursos y facilidad de desarrollo de las aplicaciones.

En nuestro caso, este aislamiento entre contenedores nos permite ejecutar en la misma máquina dos versiones distintas de Python \ref{subsec:python} (una para el micro-servicio de perfilado y la otra para el resto del \textit{backend}).
En Docker, los contenedores se define a partir de imágenes que son paquetes de solo lectura que determinan el entorno y dependencias de las aplicaciones. Estas se definen a partir de un fichero llamado Dockerfile.

Por otra parte, la utilidad \textit{Compose} de docker permite definir varios servicios que se ejecutan en contenedores independientes, pudiendo crear redes privadas entre ellos para la comunicación, evitando así exponer los mismos al exterior. Consecuentemente también se pueden especificar los puertos de red que se quieren exponer, el mapeo de directorios, y las dependencias entre los distintos servicios. Estos servicios son definidos en un fichero con formato YAML (docker-compose.yaml), permitiendo el despliegue de los mismos mediante una única instrucción de línea de comandos.

Por tanto, en nuestro caso se crearon cuatro servicios distintos para: \textit{backend}, \textit{frontend}, micro-servicio de perfilado y base de datos (MongoDb); junto con una red privada para la comunicación entre los mismos.

Una alternativa a Docker podría ser Podman\footnote{\url{https://podman.io/}} que recientemente está ganando popularidad, sin embargo, se optó por la primera debido a su gran repercusión, extensa documentación, y gran cantidad de imágenes predefinidas con las que cuenta.

\subsection{Control de versiones}

El control de versiones constituye una práctica esencial en el desarrollo de un proyecto software. Algunas de las razones de su uso son:

\begin{itemize}
    \item Seguimiento de cambios: permite registrar y rastrear las modificaciones realizadas en archivos durante el tiempo.
    \item Revisión de cambios: permite devolver el proyecto a un estado previo del mismo en caso de errores.
    \item Colaboración en equipo: facilita la colaboración en equipo en proyectos con varios miembros.
    \item Gestión de ramas: facilita el desarrollo de versiones separadas del software de forma simultánea.
\end{itemize}

Por estos motivos se escogió el uso de \textbf{Git}\footnote{\url{https://git-scm.com/}}. Git es un software de control de versiones desarrollado en 2005 por Linus Torvalds y ampliamente utilizado desde entonces. Permite mantener un registro de los cambios realizados a lo largo del ciclo de vida de un proyecto de forma eficiente y distribuida, a través del uso de repositorios locales y/o remotos.

Como plataforma de alojamiento de repositorios remotos se ha optado por Github\footnote{\url{https://github.com/}}. %Entre sus ventajas, destacan su amplia comunidad de desarrolladores, su facilidad de uso, la gran
%TODO MAYBE aumentarlo
%\subsection{Vite}%TODO

\subsection{Draw.io}

Para la creación de los diagramas que se muestran en esta memoria se optó por Draw.io\footnote{\url{https://www.drawio.com/}}. Sus mayores ventajas son que su uso es gratis, online, sencillo y con múltiples opciones de formas distintas para los diagramas, incluyendo soporte para diagramas de clase, entidad-relación, de arquitectura cloud\dots

\subsection{Editor de código}

\textbf{Visual Studio Code}\footnote{\url{https://code.visualstudio.com/}} es un editor de código gratuito desarrollado por Microsoft. Entre sus puntos fuertes están que es ligero, altamente personalizable y cuenta con funcionalidades de \acrfull{ide} como: depuración, integración de control de versiones, resaltado de sintaxis, autocompletado, refactorización. Su gran cantidad de extensiones hace que tenga soporte para casi cualquier lenguaje de programación.\\
Debido a la comodidad que ofrece y la familiaridad del desarrollador con el editor, se utilizó durante todo el proceso de desarrollo incluyendo algoritmos de perfilado, \textit{backend} y \textit{frontend}. Aunque estrictamente no sea considerado un \acrshort{ide} como tal, la gran capacidad de personalización que ofrece, puede sustituir la necesidad de emplear otro \acrshort{ide}.% En este sentido no existen alternativas a este que sean tan completas

\subsection{Prototipado}

Para realizar los prototipos de la interfaz web se ha utilizado \textbf{Balsamiq}\footnote{\url{https://balsamiq.com/}}. Balsamiq es una herramienta de prototipado para realizar diseños de interfaz de usuario de baja fidelidad, conocidos como \gls{mockups}. Esta herramienta cuenta con aplicación de escritorio, así como una versión web de la misma que te permite alojar tus prototipos en la nube. Además cuenta con una amplia biblioteca de componentes prediseñados como botones, cuadros de texto, iconos que los desarrolladores pueden usar para armar fácilmente sus \gls{mockups}.